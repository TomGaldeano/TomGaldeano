#!/usr/bin/env python3
"""
Convert a B/W image to a watertight STL heightmap (with sides and base).
For 3D printing.

Dependencies:
    pip install pillow numpy
"""
"""
scale-x, scale-y: model footprint size (units per pixel).

scale-z: height scaling.

--invert: flip heights (black high, white low).

--max-size: downscale to avoid huge meshes.
"""
import argparse
import struct
from math import sqrt
from PIL import Image
import numpy as np


def load_image_as_heightmap(path, max_size=None, invert=False):
    im = Image.open(path).convert("L")  # grayscale
    if max_size:
        w, h = im.size
        factor = min(1.0, float(max_size) / max(w, h))
        if factor < 1.0:
            im = im.resize((int(w * factor), int(h * factor)), Image.LANCZOS)
    arr = np.asarray(im, dtype=np.float32) / 255.0  # normalize 0..1
    if invert:
        arr = 1.0 - arr
    return arr  # shape (H, W)


def build_vertices(heightmap, scale_x=1.0, scale_y=1.0, scale_z=1.0):
    H, W = heightmap.shape
    xs = np.arange(W) * scale_x
    ys = np.arange(H) * scale_y
    # Center the grid around origin
    x0 = -(xs[-1] - xs[0]) / 2.0
    y0 = -(ys[-1] - ys[0]) / 2.0
    verts = np.zeros((H, W, 3), dtype=np.float32)
    for i in range(H):
        for j in range(W):
            verts[i, j, 0] = x0 + xs[j]
            verts[i, j, 1] = y0 + ys[i]
            verts[i, j, 2] = heightmap[i, j] * scale_z
    return verts


def triangle_normal(v1, v2, v3):
    ux, uy, uz = v2 - v1
    vx, vy, vz = v3 - v1
    nx = uy * vz - uz * vy
    ny = uz * vx - ux * vz
    nz = ux * vy - uy * vx
    norm = sqrt(nx * nx + ny * ny + nz * nz)
    if norm == 0.0:
        return np.array([0.0, 0.0, 0.0], dtype=np.float32)
    return np.array([nx / norm, ny / norm, nz / norm], dtype=np.float32)


def add_surface_triangles(verts):
    H, W, _ = verts.shape
    triangles = []
    for i in range(H - 1):
        for j in range(W - 1):
            v00 = verts[i, j]
            v10 = verts[i, j + 1]
            v01 = verts[i + 1, j]
            v11 = verts[i + 1, j + 1]
            # Upper surface (topography)
            nA = triangle_normal(v00, v10, v11)
            nB = triangle_normal(v00, v11, v01)
            triangles.append((nA, v00, v10, v11))
            triangles.append((nB, v00, v11, v01))
    return triangles


def add_base_and_walls(verts):
    H, W, _ = verts.shape
    triangles = []
    z0 = 0.0

    # Bottom plane
    for i in range(H - 1):
        for j in range(W - 1):
            v00 = verts[i, j].copy(); v00[2] = z0
            v10 = verts[i, j + 1].copy(); v10[2] = z0
            v01 = verts[i + 1, j].copy(); v01[2] = z0
            v11 = verts[i + 1, j + 1].copy(); v11[2] = z0
            # Flip order so normal faces downward
            nA = triangle_normal(v00, v11, v10)
            nB = triangle_normal(v00, v01, v11)
            triangles.append((nA, v00, v11, v10))
            triangles.append((nB, v00, v01, v11))

    # Side walls (around border)
    def wall_quad(vtop1, vtop2):
        vbot1, vbot2 = vtop1.copy(), vtop2.copy()
        vbot1[2] = z0
        vbot2[2] = z0
        n1 = triangle_normal(vtop1, vtop2, vbot2)
        n2 = triangle_normal(vtop1, vbot2, vbot1)
        return [(n1, vtop1, vtop2, vbot2),
                (n2, vtop1, vbot2, vbot1)]

    # Top edge
    for j in range(W - 1):
        triangles += wall_quad(verts[0, j], verts[0, j + 1])
    # Bottom edge
    for j in range(W - 1):
        triangles += wall_quad(verts[H - 1, j + 1], verts[H - 1, j])
    # Left edge
    for i in range(H - 1):
        triangles += wall_quad(verts[i + 1, 0], verts[i, 0])
    # Right edge
    for i in range(H - 1):
        triangles += wall_quad(verts[i, W - 1], verts[i + 1, W - 1])

    return triangles


def write_binary_stl(path, triangles, header=b"Generated by img2stl_solid"):
    hdr = header[:80].ljust(80, b' ')
    with open(path, "wb") as f:
        f.write(hdr)
        f.write(struct.pack("<I", len(triangles)))
        for n, v1, v2, v3 in triangles:
            f.write(struct.pack("<3f", *n))
            f.write(struct.pack("<3f", *v1))
            f.write(struct.pack("<3f", *v2))
            f.write(struct.pack("<3f", *v3))
            f.write(struct.pack("<H", 0))


def main():
    parser = argparse.ArgumentParser(description="Convert B/W image to solid STL (heightmap).")
    parser.add_argument("input", help="Input image")
    parser.add_argument("output", help="Output STL file")
    parser.add_argument("--scale-x", type=float, default=1.0)
    parser.add_argument("--scale-y", type=float, default=1.0)
    parser.add_argument("--scale-z", type=float, default=5.0)
    parser.add_argument("--max-size", type=int, default=400)
    parser.add_argument("--invert", action="store_true")
    args = parser.parse_args()

    hm = load_image_as_heightmap(args.input, max_size=args.max_size, invert=args.invert)
    verts = build_vertices(hm, args.scale_x, args.scale_y, args.scale_z)

    tris = []
    tris += add_surface_triangles(verts)
    tris += add_base_and_walls(verts)

    print(f"Writing {len(tris)} triangles to {args.output}")
    write_binary_stl(args.output, tris)


if __name__ == "__main__":
    main()

